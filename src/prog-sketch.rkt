#lang rosette

(require "ast.rkt"
         "matrix-utils.rkt"
         threading)

(provide (all-defined-out))

(define (make-symbolic-vector ty size)
  (for/vector ([_ (in-range size)])
    (define-symbolic* v ty)
    v))

(define make-symbolic-int-vector
  (curry make-symbolic-vector integer?))

(define (make-symbolic-indices-restriced size reg-limit reg-upper-bound)
  (define vec (make-symbolic-int-vector size))
  (assert (<= (reg-used vec size reg-upper-bound) reg-limit))
  vec)

(define (make-symbolic-matrix rows cols)
  (matrix rows cols (make-symbolic-int-vector (* rows cols))))

;;=================== SKETCH DEFINITIONS =========================

; Generate a sketch that interleaves computation and shuffling `iterations`
; times.
; `shuffle-thunk` takes one argument, the current iteration, and returns a list
; of program insts and names of shuffle vectors defined.
; `compute-thunk` takes two arguments, the current iteration and the names of the
; shuffle vectors for this iteration, and returs a list of program insts.
(define (sketch-compute-shuffle-interleave shuffle-thunk
                                           compute-thunk
                                           number)
  (define instructions
    (for/list ([i (in-range number)])
      (define-values (shuffle-defs shuffle-names)
        (shuffle-thunk i))
      (define compute
        (compute-thunk i shuffle-names))
      (append shuffle-defs compute)))

  (flatten instructions))

; Returns a function that generates `shuf-num` shuffle vectors of size
; `reg-size` to be used for a program sketch.
(define (symbolic-shuffle-gen shuf-num)
  (lambda (iteration)
    (define shuf-names
      (for/list ([n (in-range shuf-num)])
        (string->symbol
          (string-append "shuf"
                         (number->string n)
                         "-"
                         (number->string iteration)))))
    (define insts
      (map (lambda (shuf-name)
             (vec-const shuf-name
                        (make-symbolic-int-vector (current-reg-size))))
           shuf-names))
    (values insts shuf-names)))


; Equivalence classes based on names generated by symbolic-shuffle-gen.
; Names are of the form shufn-i where n is the class number.
(define (prefix-equiv name)
  (~> name
      symbol->string
      (string-split _ "-")
      first
      (string-split _ "shuf")
      first
      string->number))

; TODO(rachit): Define a sketch where the compute can use previously defined
; shuffle vectors. The sketch should take a parameter `n` that specifies the
; "history" of shuffle vectors the compute at iteration `i` can use.
; For example, for n = 3, computation at `i` can choose to use shuffle
; vectors from `i-2`, `i-1`, and `i`. This choice allows the sketch to
; discover reuse of shuffle vectors while also giving us a parameter to
; tune the complexity of the synthesis formulation.
;
; Note that this "history" based mechanism doesn't disallow global reuse
; patterns as long as the compute kernels can commute. To reuse a shuffle
; vector that is further away, the synthesizer can simply reorder the
; computation.
(define (sketch-compute-shuffle-interleave-history shuffle-thunk
                                                   compute-thunk
                                                   number
                                                   #:window-size window-size)

  (define (take-window vec start end)
    (vector-take (vector-drop vec
                              (max 0 start)
                              start)
                 (add1 end)))

  ; Store the names of currently defined shufs
  (define def-shufs (make-vector number #f))

  (define instructions
    (for/list ([i (in-range number)])
      (define-values (shuffle-defs shuffle-names)
        (shuffle-thunk i))
      (vector-set! def-shufs i shuffle-names)
      (define compute
        (compute-thunk i (take-window (- i window-size) i)))
      (append (shuffle-defs compute))))

  (flatten instructions))
