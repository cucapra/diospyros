#lang rosette

(require "ast.rkt"
         "utils.rkt"
         "configuration.rkt"
         racket/trace
         threading)

(provide (all-defined-out))

(define (make-symbolic-bv-list ty size)
  (for/list ([_ (in-range size)])
    (define-symbolic* v ty)
    (box v)))

(define (make-bv-list-empty size)
  (for/list ([_ (in-range size)])
    (box void)))

(define (make-symbolic-bv-list-values size)
  (make-symbolic-bv-list (bitvector (value-fin)) size))

(define (make-symbolic-bv-list-indices size)
  (make-symbolic-bv-list (bitvector (index-fin)) size))

(define (make-symbolic-matrix rows cols)
  (matrix rows cols (make-symbolic-bv-list-values (* rows cols))))

(define (make-bv-list-zeros size)
  (for/list ([_ (in-range size)])
    (box (bv 0 (value-fin)))))

(define (bv-list width xs)
  (define elements (map (curry bitvectorize-concrete width) xs))
  (map box elements))

(define (value-bv-list . xs)
  (bv-list (value-fin) xs))

(define (index-bv-list . xs)
  (bv-list (index-fin) xs))

;;=================== SKETCH DEFINITIONS =========================

; Generate a sketch that interleaves computation and shuffling `iterations`
; times.
; `shuffle-thunk` takes one argument, the current iteration, and returns a list
; of program insts and names of shuffle vectors defined.
; `compute-thunk` takes two arguments, the current iteration and the names of the
; shuffle vectors for this iteration, and returs a list of program insts.
(define (sketch-compute-shuffle-interleave shuffle-thunk
                                           compute-thunk
                                           number)
  (define instructions
    (for/list ([i (in-range number)])
      (define-values (shuffle-defs shuffle-names)
        (shuffle-thunk i))
      (define compute
        (compute-thunk i shuffle-names))
      (append shuffle-defs compute)))

  (flatten instructions))

; Returns a function that generates `shuf-num` shuffle vectors of size
; `reg-size` to be used for a program sketch.
(define (symbolic-shuffle-gen shuf-num)
  (lambda (iteration)
    (define shuf-names
      (for/list ([n (in-range shuf-num)])
        (string->symbol
          (string-append "shuf"
                         (number->string n)
                         "-"
                         (number->string iteration)))))
    (define insts
      (map (lambda (shuf-name)
             (vec-const shuf-name
                        (make-symbolic-bv-list-indices (current-reg-size))))
           shuf-names))
    (values insts shuf-names)))


; Equivalence classes based on names generated by symbolic-shuffle-gen.
; Names are of the form shufn-i where n is the class number.
(define (prefix-equiv name)
  (~> name
      symbol->string
      (string-split _ "-")
      first
      (string-split _ "shuf")
      first
      string->number))

; Partition an declared vector based on the register size
(define (partition-vector id size)
  (define len (* (current-reg-size)
                 (exact-ceiling (/ size (current-reg-size)))))
  (define vals
    (for/list ([i (in-range 0 len (current-reg-size))])
      (let* ([start i]
             [end (min len (+ i (current-reg-size)))]
             [new-id (string->symbol
                       (format "~a_~a_~a" id start end))])
        (list new-id
          (vec-load new-id id start end)
          (vec-store id new-id start end)))))
  (values (map first vals) (map second vals) (map third vals)))

; TODO(rachit): Define a sketch where the compute can use previously defined
; shuffle vectors. The sketch should take a parameter `n` that specifies the
; "history" of shuffle vectors the compute at iteration `i` can use.
; For example, for n = 3, computation at `i` can choose to use shuffle
; vectors from `i-2`, `i-1`, and `i`. This choice allows the sketch to
; discover reuse of shuffle vectors while also giving us a parameter to
; tune the complexity of the synthesis formulation.
;
; Note that this "history" based mechanism doesn't disallow global reuse
; patterns as long as the compute kernels can commute. To reuse a shuffle
; vector that is further away, the synthesizer can simply reorder the
; computation.
(define (sketch-compute-shuffle-interleave-history shuffle-thunk
                                                   compute-thunk
                                                   number
                                                   #:window-size window-size)

  (define (take-window vec start end)
    (take (drop vec
                (max 0 start)
                 start)
          (add1 end)))

  ; Store the names of currently defined shufs
  (define def-shufs (make-vector number #f))

  (define instructions
    (for/list ([i (in-range number)])
      (define-values (shuffle-defs shuffle-names)
        (shuffle-thunk i))
      (bv-list-set! def-shufs i shuffle-names)
      (define compute
        (compute-thunk i (take-window (- i window-size) i)))
      (append (shuffle-defs compute))))

  (flatten instructions))
