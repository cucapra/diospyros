# `cdios`/Diospyros Example Tutorial

The following example will walk through using the `cdios` frontend for the
Diospyros compiler. `cdios` takes code in a subset of C/C++ and produces a
single equivalent output function with Tensilica G3 vector intrinsics.

For any issues you encounter in this demo, please [file an issue on our Github repo][issue].
If the issue cannot be public, you can contact the author at avh@cs.cornell.edu.

# Installation

This tutorial assumes a machine with Xtensa tools installed and accessible on
your path. For example:
```
export LM_LICENSE_FILE=<path>.lic
export XTENSA_SYSTEM=<path>/RI-2019.2-linux/
export XTENSA_CORE=XRC_FUSIONG3_MAX_BM
```

To install `cdios`, follow the instructions in the top-level README under the sections
**Prerequisites** and **(Work in progress) Compiling from C: `cdios` minimal
 C frontend**. Note that these instructions have been tested on MacOS and Linux;
 we suggest using [Windows Subsystem for Linux][wsl] if running on Windows.

# Scope

As described in the top-level README, the tool currently supports functions that
take as input arguments matrices and scalars of type `float`, and write to one
or more output matrix of type `float`. In addition, the tool currently requires
data-independent control flow (branches/loop bounds must be statically resolved,
rather than depending on dynamic input values). The tool performs best on small-to-medium
matrix sizes (performance degrades, especially in memory consumption, with over 100 elements).

# Example: transpose then multiply

For this example, we want to process two arrays of data, `a` and `b`, in
small-sized blocks. For each block, we take the transpose of the section of `a`
and multiply it by the corresponding section of `b`. We process `ITERATIONS`
many sections of data. This example assumes you are running commands from the
`diospyros/demo` directory.

## Completed example: expected speedup

A completed version of this tutorial is in the `src-completed` directory. We
can run this first to see the performance benefits of using `cdios`/Diospyros. 
This *should* work out of the box if you have completed the installation and setup properly.


From `diospyros/demo`, run `make completed` which will compile a vanilla C++ kernel and Diospyros generated kernel that composes a transpose and matrix multiply operation. 
You can checkout the `Makefile` to see what
this does. In short, we use `xt-clang++` with (`-O3 -mlongcalls -mtext-section-literals -fvectorize`)
to compile the code, then `xt-run` (with `--mem_model`) to simulate its runtime
performance. We print the result matrices for the naive version and the
optimized version of the code, and the cycle counts (from `XT_RSR_CCOUNT()` in
`XT_ISS_CYCLE_ACCURATE` mode) for each.

You should see something like this:
```
Naive : 288 cycles

82.440002, 52.220001, 69.760002, 78.220001, ;
82.180000, 51.880005, 70.190002, 81.420006, ;
42.860001, 27.370001, 47.660000, 61.360004, ;

146.700012, 158.060013, 110.740005, 134.750000, ;
137.080002, 152.920013, 100.630005, 122.259995, ;
66.639999, 101.770004, 56.180004, 66.320000, ;
Optimized : 138 cycles

82.440002, 52.220001, 69.760002, 78.220001, ;
82.180000, 51.880001, 70.190002, 81.420006, ;
42.860001, 27.370001, 47.660000, 61.360001, ;

146.700012, 158.060013, 110.740005, 134.750000, ;
137.080002, 152.920013, 100.630005, 122.260002, ;
66.639999, 101.770004, 56.180000, 66.320000, ;
```
In this result, "Naive" refers to the result which simply takes a C++ kernel and compiles it *without* intrinsics with the Tensilica compiler.
The "Optimized" version uses the optimized kernel generated by the Diospyros compiler which uses intrinsics. 
You should also see that the calculated matrices are the same between the two methods to validate functionality and that the optimized kernel is faster.

## Example walk through: using `cdios` to get these results.

This section shows how to invoke the Diospyros C-front end tool `cdios` to take a restricted C specification and generate intrinsic optimized DSP kernels.
We will first start with a file that implements the naive version of the combined transpose and matrix multiply operation but not the optimized kernel yet (i.e., the optimized version will be a stub for now).
You will see at [line 83](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L83) that there is a stub which will get filled out later in this section.

To start, open up `diospyros/demo/src/example.c` which implements the naive functionality.
You will see that the naive C++ implementations for the matrix multiply and transpose kernels [line 33](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L33) and [line 45](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L45).

For now just compile and run the code as-is with the Xtensa simulator by running `make` from
the `diospyros/demo` directory just to check that the tools work. You should see something like this:
```
xt-clang++ -O3 -mlongcalls -mtext-section-literals -fvectorize -Wno-deprecated src/example.c -o example.o
xt-run --nosummary --mem_model example.o
Naive : 268 cycles

82.440002, 52.220001, 69.760002, 78.220001, ;
//...
Optimized : 12 cycles

0.000000, 0.000000, 0.000000, 0.000000, ;
//...
82.440002
mismatch at (0,0) reference = 82.440002, actual = 0.000000, error = 82.440002 
```
The mismatch error is expected (as is the very low cycle count), because we haven't implemented the optimized
version yet, so you can ignore the result right now. To fix this, we will use `cdios` to generate an intrinsic optimized kernel to fill the stub.

To start with, create a new file `kernel.c` in the `src` directory. The `cdios` tool can
only support a subset of C, so it's easiest to start with a clean slate.

Copy the `transpose` and `matrix_multiply` functions into your new file (found [here](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L33) and [here](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L45)). You'll
also need to copy the `#define` size ([lines 9-11](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L9)).

Since we want to vectorize the functionality of these two functions together,
let's create a new function that combines their functionality. Add a new function
`transpose_then_multiply` to your `kernel.c` file. The return type should still be
void, and the arguments should be `a_in`, `b_in`, and `c_out`.

Notice, we need to tag the inputs and outputs. The arguments `a` and `b` become `a_in` and
 `b_in` respectively, and `c` becomes `c_out`. This is necessary in order to demarcate the dataflow direction relative to the kernel function boundary.

The combined function signature should look something like this:
```
void transpose_and_multiply(float *a_in, float *b_in, float *c_out) {
}
```

If we
ran `cdios` without the argument tagging, it would fail because we have not annotated any
function arguments with inputs and outputs:
```
CDIOS: Compiling C->Racket failed
Arguments should be tagged _in or _out, got  "a"
```

Finally, the Diosypros tool requires fixed input sizes to vectorize, so we revise the function signature again to
look like:
```
void transpose_and_multiply(float a_in[A_SIZE * A_SIZE],
                            float b_in[B_ROWS * B_COLS],
                            float c_out[A_SIZE * B_COLS]) {
}
```

After all of this is done, we can fill out the function body and the combined implementation of this function should look like:
```

void transpose_and_multiply(float a_in[A_SIZE * A_SIZE],
                            float b_in[B_ROWS * B_COLS],
                            float c_out[A_SIZE * B_COLS]) {

  float tmp[A_SIZE * A_SIZE];
  transpose(a_in, tmp, A_SIZE);
  matrix_multiply(tmp, b_in, c_out);
}
```

We can now run the C-front end of the Diospyros compiler `cdios` (or `cdios.py` with executable permissions) with: `cdios src/kernel.c --function transpose_and_multiply` (again use `cdios.py` if it's not installed). On success, we see:
```
Standard C compilation successful
Writing intermediate files to: build/compile-out
Header written to build/compile-out/transpose_and_multiply.h
Implementation written to build/compile-out/transpose_and_multiply.c
```
The compilation should have created a new directory `build` in whichever directory the `cdios` tool was launched from.
This directory will contain several autogenerated files under `compile-out`.
In particular, the `transpose_and_multiply.c` file contains the optimized kernel with intrinsics.

To merge this kernel into the `example.c` file from earlier, copy `transpose_and_multiply.c` and `transpose_and_multiply.h` into `diospyros/demo/src`. In `example.c` add an import:
```
#include "transpose_and_multiply.h"
```

Now, we can modify the `process_data_optimized` function to use our new version. Add the following at [line 83](https://github.com/cucapra/diospyros/blob/307df9b1a184b491e7cc3f5c75283c9e276aa557/demo/src/example.c#L83):
```
diospyros::transpose_and_multiply(a_ref, b_ref, c_ref);
```

This is the optimized kernel call which you will notice is wrapped in a `diosypros` namespace to prevent it from clashing with the naive kernel code.

Finally, replace the source definitions in `diosypros/demo/Makefile` to the following:
```
SRCS := src/example.c src/transpose_and_multiply.c
```

And run again with `make` to see the results. You should see a similar result as before with the naice kernel taking around 200 cycles and the optimized kernel being faster.

To see a completed version of this demonstration, you can also look at the `diospyros/demo/src-completed` folder for reference.

## Adjusting parameters

You can change the `ITERATIONS` variable in `src/example.c` to see
how the performance varies with the outer loop size (you don't need to rerun
`cdios` because the inner loop sizes stays fixed).

You can also adjust the inner loop size by editing the `A_SIZE`, `B_ROWS`, and
`B_COLS` variables in `src/example.c`. For these changes, `cdios` needs to run
again to optimize for the new inner loop size.

# Running your own code

The above example illustrates the main steps to running your own desired
kernel or operator through the `cdios` compiler:
1. Identify functionality that is data-independent and operates on relatively
small chunks of data at once.
2. Create a new C file with the naive implementation of that functionality. Tag
input and output names with suffixes.
3. Pass the file and function name to the `cdios` tool.
4. Move the optimized header and implementation to where you want it, and call
the new code in place of your kernel.
5. Profit? There are some cases where `cdios`/Diospyros will produce code that
is worse than the default compilers (especially `xt-clang++`), so be sure to benchmark the results.

Thanks for taking the time to read this example, and please [file bugs][issue] if you hit any issues!

# More information

You can find the full ASPLOS 2021 paper describing the Diospyros system (but not the `cdios` frontend, which is new) [here][paper]. We also have [5 minute][short] and [17 minute][long] talks describing the paper results.

[issue]: https://github.com/cucapra/diospyros/issues/new
[wsl]: https://docs.microsoft.com/en-us/windows/wsl/install-win10
[paper]: https://www.cs.cornell.edu/~avh/diospyros-asplos-2021-preprint.pdf
[short]: https://youtu.be/pGHjvPLrmRc
[long]: https://youtu.be/RvMI4prTqHY
