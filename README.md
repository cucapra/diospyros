# Diospyros

Compile code for DSPs.

## Prerequisites

### Python
- Install [Python][] > 3.0.

### Racket
- Install [Racket][] > 7.4
- Install [Rosette][] by running `raco pkg install rosette`.
- Install Racket's threading library with `raco pkg install threading`

### Rust
- Install [Rust][].

### (Optional) SMT solvers
- For translation validation, install [z3][] or [Boolector][].


[python]: https://www.python.org/downloads/
[racket]: https://github.com/racket/racket
[rosette]: https://docs.racket-lang.org/rosette-guide/index.html
[rust]: https://www.rust-lang.org/tools/install
[z3]: https://github.com/Z3Prover/z3
[boolector]: https://github.com/Boolector/boolector

## Overview

At a high level, Diospyros takes fixed-size linear algebra kernels (specified
in either a Racket DSL or with a minimal subset of C), uses Rosette's symbolic
evaluation to generate a specification, runs a vector rewrite engine written in
[egg][], then emits C with DSP-specific intrinsics.


[egg]:https://docs.rs/egg/0.5.0/egg/index.html

## (Work in progress) Compiling from C: `cdios` minimal C frontend
The minimal C frontend requires only a single file to specify a new kernel, but
it is currently limited in expressiveness.

To install `cdios`, run the following in the root directory:
```
pip3 install --user -e .
```

You can run a simple example with:
```
cdios demo/matrix-multiply.c
```

This will emit the generated C to standard out, as well as writing intermediate
files to `compile-out/*` (including the final `kernel.c`).

`cdios` runs programs through a standard C compiler (currently `gcc`) to sanity
check correctness, then does a best-effort translation to equivalent Racket.

Currently, programs must be a single C function that consumes and mutates
single-dimensional arrays (both of these restrictions are likely to be removed
in the next week or so).

In addition, the following restrictions apply:
- Arrays must have statically-specified sizes, which can be `#define`'d at the
 start of the file.
- Inputs and outputs are identified via naming convention. Inputs should be
suffixed with `_in`, and outputs should be suffixed with `out`.
- Control flow cannot be data dependent (i.e., you can branch on an index, but
not based on the value of an array at that index).

The following restrictions currently apply, but are likely to be improved/eliminated
soon:
- Early returns, breaks, and continues are not implemented yet.
- Conditionals are partially implemented.

## Compiling from Racket DSL

Specifying programs in Racket (currently useful for multi-function kernels, and
those with control flow constructs not handled by `cdios`) involves editing the
Racket source code in a few places.

- Create a new file in `src/examples/<new>.rkt`. This file must implement an
    `only-spec` functiont that consumes a configuration, and produces (1) the
    resulting specification, (2) a prelude including inputs and outputs, and (3)
    the output names and sizes of the kernel. See
     `src/examples/matrix-multiply.rkt` for an example. The configuration is a
     key value map that will be specified in JSON for a specific invocation,
     and should include a key for `'reg-size` for the register wide (typically
     4) and keys for any kernel-specific sizes.
- In `src/example-gen.rkt`, add your new file to the `require` list, then add
    the new example to the functions `known-benches` and `run-bench`.
- Run `make` to rebuild the Racket source with your new changes.
- To run your new benchmark, create a file named `<new>-params` and enter the
    desired configuration in JSON. For example, for `QProd`, we would create a
    file `q-prod-params`.

```
{
    "reg-size": 4
}
```
- Finally, run `make <new>-egg` (i.e., `make q-prod-egg`). This will emit both
    intermediate files and the final kernel (`kernel.c`) to a directory
    `<new>-out`.

## Testing

### Unit tests

To run all unit tests:
```
make test-all
```

To run the inline Racket or Rust tests, respectively:
```
make test-racket
make test-rust
```

[runt]: https://github.com/rachitnigam/runt
[rust]: https://www.rust-lang.org/

### (Out-of-date) Integration tests

We use [runt][] for snapshot testing. Simply type `runt` in the repository root
to run tests. Use the following to update expect files generated by runt:

- **-d, --diff**: Show the diffs for the missing or failing tests.
- **-s, --save**: Update the results for the missing or failing tests.
- **-o, --only**: Filter the outputs to only display the given class of tests
  (miss, fail, pass). Composes with diff and save. For example, to only save
  the results for the missing files, do `runt -s -o miss`.
