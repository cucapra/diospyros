# Diospyros

Compile code for DSPs.

## Prerequisites

### Python
- Install [Python][] > 3.0.

### Racket
- Install [Racket][] > 7.4
- Install [Rosette][] by running `raco pkg install rosette`.
- Install Racket's threading library with `raco pkg install threading`

### Rust
- Install [Rust][].

### (Optional) SMT solvers
- For translation validation, install [z3][] or [Boolector][].


[python]: https://www.python.org/downloads/
[racket]: https://github.com/racket/racket
[rosette]: https://docs.racket-lang.org/rosette-guide/index.html
[rust]: https://www.rust-lang.org/tools/install
[z3]: https://github.com/Z3Prover/z3
[boolector]: https://github.com/Boolector/boolector

## Overview

At a high level, Diospyros takes fixed-size linear algebra kernels (specified
in either a Racket DSL or with a minimal subset of C), uses Rosette's symbolic
evaluation to generate a specification, runs a vector rewrite engine written in
[egg][], then emits C with DSP-specific intrinsics.


[egg]:https://docs.rs/egg/0.5.0/egg/index.html

## Compiling from C: `cdios` minimal C frontend



## Compiling from Racket DSL

Specifying programs in Racket (currently useful for multi-function kernels, and
those with control flow constructs not handled by `cdios`) involves editing the
Racket source code in a few places.

- Create a new file in `src/examples/<new>.rkt`. This file must implement an
    `only-spec` functiont that consumes a configuration, and produces (1) the
    resulting specification, (2) a prelude including inputs and outputs, and (3)
    the output names and sizes of the kernel. See
     `src/examples/matrix-multiply.rkt` for an example. The configuration is a
     key value map that will be specified in JSON for a specific invocation,
     and should include a key for `'reg-size` for the register wide (typically
     4) and keys for any kernel-specific sizes.
- In `src/example-gen.rkt`, add your new file to the `require` list, then add
    the new example to `known-benches` and `run-bench`.
- To run your new benchmark, create a file named `<new>-params` and enter the
    desired configuration in JSON. For example, for `QProd`, we would create a
    file `q-prod-params`.

```
{
    "reg-size": 4
}
```
- Finally, run `make <new>-egg` (i.e., `make q-prod-egg`). This will emit both
    intermediate files and the final kernel (`kernel.c`) to a directory
    `<new>-out`.

## Testing

### Unit tests

To run all unit tests:
```
make test-all
```

To run the inline Racket or Rust tests, respectively:
```
make test-racket
make test-rust
```

[runt]: https://github.com/rachitnigam/runt
[rust]: https://www.rust-lang.org/

### (Out-of-date) Integration tests

We use [runt][] for snapshot testing. Simply type `runt` in the repository root
to run tests. Use the following to update expect files generated by runt:

- **-d, --diff**: Show the diffs for the missing or failing tests.
- **-s, --save**: Update the results for the missing or failing tests.
- **-o, --only**: Filter the outputs to only display the given class of tests
  (miss, fail, pass). Composes with diff and save. For example, to only save
  the results for the missing files, do `runt -s -o miss`.
